<!-- Main -->
<section id="main" class="wrapper style2">
	<div class="title">Content Files</div>
	<div class="container">
		<!-- Features -->
		<section id="features">
			<header class="style1">
				<h2>Guide to writing content files</h2>
			</header>

			<!-- Image -->
			<center>
				<img src="@pathtofile(site/images/rabbit-icon.svg)" alt="Nift bunny mascot" width=300 style="margin-bottom:40px">
			</center>

			<div class="content">
				<h4>
					Introduction
				</h4>

				<p>
					Nift has its own powerful template language which you can use in amongst any other scripting/programming/template language you want, making it even more powerful. This page outlines most of the template language with a few additional parts explained on the <a href="@pathto(docs/template_files)">template files</a> page. 
				</p>

				<p>
					The following functions available in Nift's template language are documented on this page:
					<ul style="text-indent:30px">
						<li><a href="#escaping-chars">Escaping characters</a></li>
						<li><a href="#newlines">Newlines</a></li>
						<li><a href="#comments">Comments</a></li>
						<li><a href="#input-page-info">Inputting page information</a></li>
						<li><a href="#input-site-info">Inputting site information</a></li>
						<li><a href="#input-os-info">Inputting operating system information</a></li>
						<li><a href="#input-date-time-tz-info">Inputting date, time & timezone information</a></li>
						<li><a href="#string-vars">String variables</a></li>
						<li><a href="#input-from-file">Inputting text from other files</a></li>
						<li><a href="#input-raw-from-file">Inputting raw text from other files</a></li>
						<li><a href="#paths-between-files">Paths from pages to other pages/files</a></li>
						<li><a href="#page-deps">Adding page dependencies</a></li>
						<li><a href="#scripts">Running scripts</a></li>
						<li><a href="#script-output">Inputting script output</a></li>
						<li><a href="#script-output-raw">Inputting script output raw</a></li>
						<li><a href="#system">Running system calls</a></li>
						<li><a href="#system-output">Inputting system call output</a></li>
						<li><a href="#system-output-raw">Inputting system call output raw</a></li>
						<li><a href="#user-input">User input from command-line</a></li>
						<li><a href="#user-file-input">User input from file</a></li>
						<li><a href="#css-files">Including css files</a></li>
						<li><a href="#img-files">Including image files</a></li>
						<li><a href="#js-files">Including javascript files</a></li>
						<li><a href="#favicon-file">Including a favicon file</a></li>
					</ul>
				</p>

				<p>
					<b>Note:</b> Some of the functions take input parameters, if you would like to use the template language with the input parameters for a function call then put <mono>*</mono> without any whitespace between the function name and parentheses containing the input parameters. For example:
<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@input*("\@contentpath")
</pre>
</div>
				</p>

				<h4 id="escaping-chars">
					Escaping characters
				</h4>
				<p>
					<mono>Nift</mono> will escape the following characters: \~, \!, \@, \#, \%, \^, \*, \?, \<, \>. Just put <mono>\character-to-escape</mono>, for example to escape tilde use <mono>\\~</mono>.
				</p>

				<p>
					<u>Note:</u> <mono>Nift</mono> does not, and will not, escape \$. This is because it conflicts with MathJax escaping \$. If you do not want to use MathJax on your site and want \$ escaped then manually uncomment the relevant code in <mono>PageBuilder.cpp</mono> before compiling and installing <mono>Nift</mono>.
				</p>

				<p>
					<mono>Nift</mono> does not escape & as it causes problems with some valid javascript code for example (not an issue with .js files, but is an issue for javascript code inside content/template files). You can program your own syntax for escaping & in to <mono>Nift</mono> if needed. Similarly if javascript code or otherwise is not working, one thing to try is searching for \ in all the content/template files and seeing if something is being escaped inside code, if it is comment the relevant escape code from <mono>PageBuilder.cpp</mono> then compile and install <mono>Nift</mono> again. 
				</p>

				<h4 id="newlines">
					Newlines
				</h4>
				
				<p>
					You can break up one line in the source code of content/templates files in to multiple lines in the source code for the build page/file using <mono>\@\n</mono>. For example if you have the following in one of your content files used to build a page:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="inline">
This is a line \@\nthat is broken in to\@\n three lines.
</pre>
</div>
				</p>

				<p>
					Then the built page/file will have the following written to it when it reaches that point in the build process:
<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="inline">
This is a line @\nthat is broken in to@\n three lines.
</pre>
</div>
				</p>

				<h4 id="comments">
					Comments
				</h4>

				<p>
					If you are building <mono>html</mono> or <mono>php</mono> pages with Nift then you can use <mono>html</mono> or <mono>php</mono> coments in your content and template files which will also appear in the source code for the built pages. If you are building pages of another language with Nift, you should also have no problems using the comment syntax for that language in your content and template files which will appear in the source code for the built pages/files. The following syntax is available for comments that will be stripped and not appear in the source code for built pages:

					<center>
						<table id="comments_syntax_table" class="alt">
							<thead>
								<tr>
									<th>type</th>
									<th>syntax</th>
								</tr>
							</thead>
							<tr>
								<td>raw single-line comment</td>
								<td><mono>\@# <i>comment-text</i></mono></td>
							</tr>
							<tr>
								<td>parsed single-line comment</td>
								<td><mono>\@// <i>comment-text</i></mono></td>
							</tr>
							<tr>
								<td>special parsed single-line comment</td>
								<td><mono>\@!\n <i>comment-text</i></mono></td>
							</tr>
							<tr>
								<td>raw multi-line comment</td>
								<td><mono><\@-- <i>comment-text</i> --\@></mono></td>
							</tr>
							<tr>
								<td>parsed multi-line comment</td>
								<td><mono>\@/* <i>comment-text</i> \@*/</mono></td>
							</tr>
							<tr>
								<td>special parsed multi-line comment</td>
								<td>
									<mono>
										\@---<br>
										<i>comment-text</i><br>
										\@---
									</mono>
								</td>
							</tr>
							<tfoot>
								<tr>
									<th>type</th>
									<th>syntax</th>
								</tr>
							</tfoot>
						</table>
					</center>
				</p>

				<p>
					The syntax for Nift comments should be reasonably easy to remember as it is very close to the comment syntax people will be used to from languages like html, php, javascript, css, bash, python, C/C++, etc.. It also has the added benefit of being easy to turn comments from those languages in to Nift comments, and being easy to turn back again.
				</p>

				<p>
					<u>Raw vs. Parsed:</u> Parsed comments have the comment text parsed with Nift's template language, so for example string definitions would be recognised, whereas raw comments do <u>not</u> have the comment text parsed with Nift's template language. 
				</p>

				<p>
					<u>Special parsed single-line comments</u> are almost the same as parsed single-line comments except that in the source code for the built page/file the following line is placed on the same line after the text before <mono>\@!\n</mono>. You cannot put two instances of <mono>\@!\n</mono> on the same line, Nift will throw a build error.
				</p>

				<p>
					With raw and parsed multi-line comments, even if you comment out entire lines the build page/file will still have one empty line where the comment was. This is where <u>special parsed multi-line comments</u> come in to play, if you use them then the source code for the build page/file will not have any blank line where the comment was in the content or template file. 
				</p>

				<p>
					<b>Note:</b> While you can open and close raw and parsed multi-line comments anywhere on a line, including opening and closing on the same line, special parsed multi-line comments are for commenting out sections of entire lines. The open and close tags should each be on individual lines without even any leading/trailing whitespace. 
				</p>

				<h4 id="input-page-info">
					Inputting page information
				</h4>
				<p>
					The following information about the page being built can be injected:

					<center>
						<table id="page_info_syntax_table" class="alt">
							<thead>
								<tr>
									<th>type</th>
									<th>syntax</th>
								</tr>
							</thead>
							<tr>
								<td>page name</td>
								<td><mono>\@pagename</mono></td>
							</tr>
							<tr>
								<td>page title</td>
								<td><mono>\@pagetitle</mono></td>
							</tr>
							<tr>
								<td>page path</td>
								<td><mono>\@pagepath</mono></td>
							</tr>
							<tr>
								<td>page page extension</td>
								<td><mono>\@pagepageext</mono></td>
							</tr>
							<tr>
								<td>content path</td>
								<td><mono>\@contentpath</mono></td>
							</tr>
							<tr>
								<td>page content extension</td>
								<td><mono>\@pagecontentext</mono></td>
							</tr>
							<tr>
								<td>page script extension</td>
								<td><mono>\@pagescriptext</mono></td>
							</tr>
							<tr>
								<td>template path</td>
								<td><mono>\@templatepath</mono></td>
							</tr>
							<tfoot>
								<tr>
									<th>type</th>
									<th>syntax</th>
								</tr>
							</tfoot>
						</table>
					</center>

					For example in a file <mono>template/head.content</mono> you may want something along the lines of <mono>\<title>sitename - \@pagetitle\</title></mono>.
				</p>

				<h4 id="input-site-info">
					Inputting site information
				</h4>
				<p>
					The following information about the website <mono>Nift</mono> is tracking can be injected:

					<center>
						<table id="site_info_syntax_table" class="alt">
							<thead>
								<tr>
									<th>type</th>
									<th>syntax</th>
								</tr>
							</thead>
							<tr>
								<td>content directory</td>
								<td><mono>\@contentdir</mono></td>
							</tr>
							<tr>
								<td>(built) site directory</td>
								<td><mono>\@sitedir</mono></td>
							</tr>
							<tr>
								<td>content extension</td>
								<td><mono>\@contentext</mono></td>
							</tr>
							<tr>
								<td>page extension</td>
								<td><mono>\@pageext</mono></td>
							</tr>
							<tr>
								<td>script extension</td>
								<td><mono>\@scriptext</mono></td>
							</tr>
							<tr>
								<td>default template</td>
								<td><mono>\@defaulttemplate</mono></td>
							</tr>
							<tfoot>
								<tr>
									<th>type</th>
									<th>syntax</th>
								</tr>
							</tfoot>
						</table>
					</center>
				</p>

				<h4 id="input-os-info">
					Inputting operating system information
				</h4>
				<p>
					You can use <mono>\@buildOS</mono> to add whether a page was built using <mono>Nift</mono> on Linux, Macintosh or Windows (<mono>\@currentOS</mono> will continue to do the same for backwards compatibility purposes). 
				</p>

				<h4 id="input-date-time-tz-info">
					Inputting date, time and timezone information
				</h4>
				<p>
					The date and time that a page was built may be inputted using <mono>\@builddate</mono> and <mono>\@buildtime</mono> (<mono>\@currentdate</mono> and <mono>\@currenttime</mono> will continue to do the same for backwards compatibility purposes). The timezone this date and time information is associated with may also be inputted using <mono>\@buildtimezone</mono> (<mono>\@timezone</mono> will continue to do the same for backwards compatibility purposes).
				</p>

				<p>
					The date and time that a page was loaded may be inputted using <mono>\@loaddate</mono> and <mono>\@loadtime</mono>. The timezone this date and time information is associated with (ie. where the user is browsing the internet from) may also be inputted using <mono>\@loadtimezone</mono>.
				</p>

				<p>
					Also available are <mono>\@buildUTCtime</mono>, <mono>\@buildUTCdate</mono>, <mono>\@buildYY</mono> and <mono>\@buildYYYY</mono> (with <mono>\@currentUTCtime</mono>, <mono>\@currentUTCdate</mono>, <mono>\@currentYY</mono> and <mono>\@currentYYYY</mono> doing the same for backwards compatibility purposes), along with <mono>\@loadUTCtime</mono>, <mono>\@loadUTCdate</mono>, <mono>\@loadYY</mono> and <mono>\@loadYYYY</mono>.
				</p>

				<h4 id="string-vars">
					String variables
				</h4>
				<p>
					You can define string variables using <mono>\@stringdef(<i>varName</i> = <i>varValue</i>)</mono>, where <mono><i>varName</i></mono> is the variable name and <mono><i>varValue</i></mono> is the variable value. For example you might have:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
\@stringdef(str = "hello, world!")
</pre>
</div>
				</p>

				<p>
					<b>Note:</b> variable names containing the characters <mono>'='</mono>, <mono>')'</mono> or <mono>' '</mono> should be quoted.
				</p>

				<p>
					<b>Note:</b> you can use <mono>\'</mono> for <mono>'</mono> and <mono>\"</mono> for <mono>"</mono> in variable values. 
				</p>

				<p>
					You can reference string variables using <mono>\@string(<i>varName</i>)</mono>, where <mono><i>varName</i></mono> is the variable name. For example to reference the string defined above use:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
\@string(str)
</pre>
</div>
				</p>

				<h4 id="input-from-file">
					Inputting text from other files
				</h4>
				<p>
					Text may be inputted from another file using <mono>\@input(path-to-file)</mono>, where <mono>path-to-file</mono> is the path from the main project directory to the input file.
				</p>

				<p>
					For example suppose inside your website directory you have <mono>template/footer.content</mono>:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
Page was last built on \@currentdate.
</pre>
</div>
				</p>

				<p>
					To input <mono>template/footer.content</mono> into another file write:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@input("template/footer.content")
</pre>
</div>
				</p>

				<p>
					<u>Note:</u> <mono>Nift</mono> will not let you create an input loop, for example you cannot have <mono>\@input(page.template)</mono> inside <mono>page.template</mono>, or any of the files that <mono>page.template</mono> inputs, or any of the files that they input, and so on. 
				</p>

				<h4 id="input-raw-from-file">
					Inputting raw text from other files
				</h4>
				<p>
					Raw text (so not parsed with Nift's template language) may be inputted from another file using <mono>\@inputraw(path-to-file)</mono>, where <mono>path-to-file</mono> is the path from the main project directory to the input file.
				</p>

				<p>
					For example suppose inside your website directory you have <mono>template/footer.content</mono>.
				</p>

				<p>
					To raw input <mono>template/footer.content</mono> into another file write:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@inputraw("template/footer.content")
</pre>
</div>
				</p>

				<h4 id="paths-between-files">
					Path from pages to other pages/files
				</h4>

				<p>
					It is possible for pages $A$ and $B$ to be located in distinct directories yet input text from the same content file $X$. Consequently if content file $X$ contains a path to another page $Y$, you have the problem that the path from $A$ to $Y$ is not the same as the path from $B$ to $Y$. You can solve this non-constant path problem by using <mono>\@pathto(page-name)</mono> or <mono>\@pathtopage(page-name)</mono> where <mono>page-name</mono> is the page name for $Y$. When building a page, <mono>Nift</mono> will replace <mono>\@pathto(page-name)</mono> with the path from the page being built to page $Y$.
				</p>

				<p>
					An example of when users may find this useful is when writing menus for page templates, or adding local links for any template files. An example of a smaller version of the menu for this site using <mono>\@pathto(page-name)</mono> is below:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint linenums">
<nav>
	<ul class="drop_menu">
		<li></li>
		<li class="dm_li">
			<a href="\@pathto(index)">Home</a>
		</li>

		<li class ="dm_li">
			<div class="dm_text">Documentation</div>
			<ul class ="drop_submenu">
				<li class="dsm_li"><a href="\@pathto(documentation/installing_nift)">Installing Nift</a></li>
				<li class="dsm_li"><a href="\@pathto(documentation/nift_tutorial)">Nift tutorial</a></li>
				<li class="dsm_li"><a href="\@pathto(documentation/nift_commands)">Nift commands</a></li>
			</ul>
		</li>

		<li class ="dm_li">
			<a href="\@pathto(support)">Support</a>
		</li>
		<li></li>
	</ul>
</nav>
</pre>
</div>
				</p>

				<p>
					When using <mono>\@pathto(page-name)</mono> or <mono>\@pathtopage(page-name)</mono>, <mono>Nift</mono> will throw an error if the page is not being tracked by <mono>Nift</mono>. You can solve the non-constant path problem for arbitrary files by using <mono>\@pathtofile(path-to-file)</mono> where <mono>path-to-file</mono> is the path from the main project directory to file $Y$ (where page $Y$ above has been replaced with file $Y$). When building a page, <mono>Nift</mono> will throw an error if the file does not exist. 
				</p>

				<p>
					The footer content file for this site (inputted in the <mono>template/page.template</mono> file) is given below as an example using <mono>\@pathtofile(path-to-file)</mono>:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint linenums">
<footer>
	<hr>
	<center><img src="\@pathtofile(site/files/nsm.png)" width="120"></center>

	<p>
		<b>Mirrors:</b> [<a href="https://nift.cc/">Official</a>] [<a href="https://nifty-site-manager.bitbucket.io/">BitBucket</a>] [<a href="https://nifty-site-manager.github.io/">GitHub</a>] [<a href="https://nifty-site-manager.gitlab.io/">GitLab</a>]
	</p>

	<p>
		<b>Repos:</b> [<a href="https://bitbucket.org/nifty-site-manager/nsm/src/master/">BitBucket</a>] [<a href="https://github.com/nifty-site-manager/nsm">GitHub</a>] [<a href="https://gitlab.com/nifty-site-manager/nsm">GitLab</a>]
	</p>

	Page was last built on \@currentdate at \@currenttime (\@timezone) using \@currentOS. <br>

	<noselect><small>&copy;&nbsp;2015-\@loadYY <a href="https://n-ham.com/">Nicholas Ham</a></small></noselect>
</footer>
</pre>
</div>
				</p>

				<h4 id="page-deps">Adding page dependencies</h4>
				<p>
					Page dependencies may be added using <mono>\@dep(dep-path)</mono>, where <mono>dep-path</mono> is the path from the main project directory to the dependency file.
				</p>

				<p>
					You can also add page dependencies manually by adding a <mono>.deps</mono> file residing in the same directory as the content file for the page. For example if you have <mono>index.content</mono> as the page content file add an <mono>index.deps</mono> file containing the extra dependencies you want to track. 
				</p>


				<h4 id="scripts">Running scripts</h4>
				<p>
					Scripts may be run using <mono>\@script(script-path)</mono>, where <mono>script-path</mono> is the path from the project root directory to the script, which is basically the same as the system call for the script. If you need to pass parameters to your scripts you can use <mono>\@script(script-path, script-parameters)</mono> where <mono>script-parameters</mono> is a quoted string of parameters (use single outer quotes and double inner quotes for parameters with spaces).
				</p>

				<p>
					For example if you want to run a script <mono>'script.py'</mono>, you can do so with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
\@script('./script.py')
</pre>
</div>
				</p>

				<p>
					Also if for example you want to run a script <mono>'script.py'</mono> while passing in the parameters <mono>"light blue"</mono> and <mono>red</mono>, you can do so with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
\@script('./script.py', '"light blue" red')
</pre>
</div>
				</p>

				<p>
					<b>Note:</b> Scripts/programs run with <mono>\@script</mono> calls are moved to the project root directory to run and have a backup copy made. If scripts/programs are so large that copying the file will take time, or you are making lots of calls which is slower at scale, you can use the <mono>'^'</mono> option to not have the script backed up, eg.: 
<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
\@script^('./script.py')
</pre>
</div>
				</p>

				<p>
					If you need to use Nift's template language with the input parameters for the <mono>\@script</mono> call as well then you can do either <mono>\@script*^(script-path)</mono> or <mono>\@script^*(script-path)</mono>.
				</p>

				<p>
					Alternatively you can write scripts/programs that you run yourself (not using Nift) which they themselves add the Nift build process in to them, leaving you with just one program that you need to run when building. You will still get to take advantage of Nift's unbeaten build times and powerful template language doing this.
				</p>

				<p>
					<b>Note:</b> If you need to have different pages running the same script during the build process you will either need to set the number of build threads to <mono>1</mono> or put up with having to rebuild on the occassions where Nift unsuccessfully tries to run both scripts at the same time. You can always have duplicate copies of the same script in different files and have each page run a different version.
				</p>

				<p>
					<b>Note:</b> Scripts and system calls are run from the project root directory so all paths in your scripts should start from there. Also do not change directory in your scripts as it will mess up the other threads that are also building pages. If you really must change directories in your scripts then you will have to set the number of build threads to 1 and change back to the project root directory before each script ends. Also you will not see the output of your scripts until after they have finished running, so user input is not recommended as you can not display a message.
				</p>

				<p>
					<b>Note:</b> <mono>\@script</mono> calls do not scale very well to hundreds of thousands of calls, it is much better to combine as much as possible in to as few <mono>\@script</mono> calls as possible for extremely large projects (moving stuff to the pre/post build scripts is the best place, you can output stuff to file and process the files when building). For example if possible it's much faster to have a few pre-build scripts to download text from multiple urls using cURL, and/or make all the api calls, all the database queries, and work on JSON data needed and distribute the needed output in to different files to be inputted when needed. Note that page-specific build scripts have the benefit of multithreading, whereas site-wide build scripts wont have any multithreading unless you code it in there yourself.
				</p>

				<h4 id="script-output">Inputting script output</h4>
				<p>
					Output from scripts may be inputted at any point when building webpages using <mono>\@scriptoutput(script-path)</mono>, where where <mono>script-path</mono> is the path from the main project directory to the script, which is basically the same as the system call for the script. If you need to pass parameters to your scripts you can use <mono>\@scriptoutput(script-path, script-parameters)</mono> where <mono>script-parameters</mono> is a quoted string of parameters (use single outer quotes and double inner quotes for parameters with spaces). This can be incredibly useful for things like conditional statements/loops, or integrating with databases, GraphQL and scripting languages etc., which is just the tip of the ice berg!
				</p>

				<p>
					For example suppose you want to input the output from running a script <mono>"linux script.py"</mono>, you can do so with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@scriptoutput('./linux script.py')
</pre>
</div>

				<p>
					<b>Note:</b> Scripts/programs run with <mono>\@scriptoutput</mono> calls are moved to the project root directory to run and have a backup copy made. If scripts/programs are so large that copying the file will take time, or you are making lots of calls which is slower at scale, you can use the <mono>'^'</mono> option to not have the script backed up, eg.: 
<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
\@scriptoutput^('./script.py')
</pre>
</div>
				</p>

				<p>
					If you need to use Nift's template language with the input parameters for the <mono>\@scriptoutput</mono> call as well then you can do either <mono>\@scriptoutput*^(script-path)</mono> or <mono>\@scriptoutput^*(script-path)</mono>.
				</p>

				<p>
					Alternatively you can write scripts/programs that you run yourself (not using Nift) which they themselves add the Nift build process in to them, leaving you with just one program that you need to run when building. You will still get to take advantage of Nift's unbeaten build times and powerful template language doing this.
				</p>

				<p>
					<b>Note:</b> If you need to have different pages running the same script during the build process you will either need to set the number of build threads to <mono>1</mono> or put up with having to rebuild on the occassions where Nift unsuccessfully tries to run both scripts at the same time. You can always have duplicate copies of the same script in different files and have each page run a different version.
				</p>

				<p>
					<b>Note:</b> Scripts and system calls are run from the project root directory so all paths in your scripts should start from there. Also do not change directory in your scripts as it will mess up the other threads that are also building pages. If you really must change directories in your scripts then you will have to set the number of build threads to 1 and change back to the project root directory before each script ends. Also you will not see the output of your scripts until after they have finished running, so user input is not recommended as you can not display a message.
				</p>

				<p>
					<b>Note:</b> <mono>\@scriptoutput</mono> calls do not scale very well to hundreds of thousands of calls, it is much better to combine as much as possible in to as few <mono>\@script</mono> calls as possible for extremely large projects (moving stuff to the pre/post build scripts is the best place, you can output stuff to file and process the files when building). For example if possible it's much faster to have a few pre-build scripts to download text from multiple urls using cURL, and/or make all the api calls, all the database queries, and work on JSON data needed and distribute the needed output in to different files to be inputted when needed. Note that page-specific build scripts have the benefit of multithreading, whereas site-wide build scripts wont have any multithreading unless you code it in there yourself.
				</p>

				<h4 id="script-output-raw">Inputting script output raw</h4>
				<p>
					Raw output from scripts (so not parsed with Nift's template language) may be inputted at any point when building webpages using <mono>\@scriptraw(script-path)</mono>, where where <mono>script-path</mono> is the path from the main project directory to the script, which is basically the same as the systemraw call for the script. If you need to pass parameters to your scripts you can use <mono>\@scriptraw(script-path, script-parameters)</mono> where <mono>script-parameters</mono> is a quoted string of parameters (use single outer quotes and double inner quotes for parameters with spaces).

				<p>
					For example suppose you want to input the raw output from running a script <mono>"linux script.py"</mono>, you can do so with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@scriptraw('./linux script.py')
</pre>
</div>

				<p>
					<b>Note:</b> Scripts/programs run with <mono>\@scriptraw</mono> calls are moved to the project root directory to run and have a backup copy made. If scripts/programs are so large that copying the file will take time, or you are making lots of calls which is slower at scale, you can use the <mono>'^'</mono> option to not have the script backed up, eg.: 
<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline lang-bash">
\@scriptraw^('./script.py')
</pre>
</div>
				</p>

				<p>
					If you need to use Nift's template language with the input parameters for the <mono>\@scriptraw</mono> call as well then you can do either <mono>\@scriptraw*^(script-path)</mono> or <mono>\@scriptraw^*(script-path)</mono>.
				</p>

				<p>
					Alternatively you can write scripts/programs that you run yourself (not using Nift) which they themselves add the Nift build process in to them, leaving you with just one program that you need to run when building. You will still get to take advantage of Nift's unbeaten build times and powerful template language doing this.
				</p>

				<p>
					<b>Note:</b> If you need to have different pages running the same script during the build process you will either need to set the number of build threads to <mono>1</mono> or put up with having to rebuild on the occassions where Nift unsuccessfully tries to run both scripts at the same time. You can always have duplicate copies of the same script in different files and have each page run a different version.
				</p>

				<p>
					<b>Note:</b> Scripts and system calls are run from the project root directory so all paths in your scripts should start from there. Also do not change directory in your scripts as it will mess up the other threads that are also building pages. If you really must change directories in your scripts then you will have to set the number of build threads to 1 and change back to the project root directory before each script ends. Also you will not see the output of your scripts until after they have finished running, so user input is not recommended as you can not display a message.
				</p>

				<p>
					<b>Note:</b> <mono>\@scriptraw</mono> calls do not scale very well to hundreds of thousands of calls, it is much better to combine as much as possible in to as few <mono>\@script</mono> calls as possible for extremely large projects (moving stuff to the pre/post build scripts is the best place, you can output stuff to file and process the files when building). For example if possible it's much faster to have a few pre-build scripts to download text from multiple urls using cURL, and/or make all the api calls, all the database queries, and work on JSON data needed and distribute the needed output in to different files to be inputted when needed. Note that page-specific build scripts have the benefit of multithreading, whereas site-wide build scripts wont have any multithreading unless you code it in there yourself.
				</p>

				<h4 id="system">Running system calls</h4>
				<p>
					System calls may be run using <mono>\@system(system-call)</mono>, where <mono>system-call</mono> is the system call or you want to run. 
				</p>

				<p>
					For example suppose you want to convert the markdown file <mono>file.md</mono> to html using pandoc and save it in <mono>out.html</mono>, you can do so with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@system('pandoc -o out.html file.md')
</pre>
</div>

				<p>
					<b>Note:</b> you can use <mono>\'</mono> for <mono>'</mono> and <mono>\"</mono> for <mono>"</mono> in system-calls. 
				</p>

				<p>
					<b>Note:</b> Scripts and system calls are run from the project root directory so all paths in your scripts should start from there. Also do not change directory in your scripts as it will mess up the other threads that are also building pages. If you really must change directories in your scripts then you will have to set the number of build threads to 1 and change back to the project root directory before each script ends. Also you will not see the output of your scripts until after they have finished running, so user input is not recommended as you can not display a message.
				</p>

				<p>
					<b>Note:</b> <mono>\@system</mono> calls do not scale very well to hundreds of thousands of calls, it is much better to combine as much as possible in to as few <mono>\@script</mono> calls as possible for extremely large projects (moving stuff to the pre/post build scripts is the best place, you can output stuff to file and process the files when building). For example if possible it's much faster to have a few pre-build scripts to download text from multiple urls using cURL, and/or make all the api calls, all the database queries, and work on JSON data needed and distribute the needed output in to different files to be inputted when needed. Note that page-specific build scripts have the benefit of multithreading, whereas site-wide build scripts wont have any multithreading unless you code it in there yourself.
				</p>

				<h4 id="system-output">Inputting system call output</h4>
				<p>
					Output from system calls may be inputted at any point when building webpages using <mono>\@systemoutput(system-call)</mono>, where <mono>system-call</mono> is the system call or script you want to run. This can be incredibly useful for things like conditional statements/loops, inputting text from a url using cURL, or integrating with databases, GraphQL and scripting languages etc., which is just the tip of the ice berg!
				</p>

				<p>
					<b>Note:</b> you can use <mono>\'</mono> for <mono>'</mono> and <mono>\"</mono> for <mono>"</mono> in system-calls. 
				</p>

				<p>
					<b>Note:</b> Scripts and system calls are run from the project root directory so all paths in your scripts should start from there. Also do not change directory in your scripts as it will mess up the other threads that are also building pages. If you really must change directories in your scripts then you will have to set the number of build threads to 1 and change back to the project root directory before each script ends. Also you will not see the output of your scripts until after they have finished running, so user input is not recommended as you can not display a message.
				</p>

				<p>
					<b>Note:</b> <mono>\@systemoutput</mono> calls do not scale very well to hundreds of thousands of calls, it is much better to combine as much as possible in to as few <mono>\@script</mono> calls as possible for extremely large projects (moving stuff to the pre/post build scripts is the best place, you can output stuff to file and process the files when building). For example if possible it's much faster to have a few pre-build scripts to download text from multiple urls using cURL, and/or make all the api calls, all the database queries, and work on JSON data needed and distribute the needed output in to different files to be inputted when needed. Note that page-specific build scripts have the benefit of multithreading, whereas site-wide build scripts wont have any multithreading unless you code it in there yourself.
				</p>

				<p>
					For example suppose you want to input the text from <a href="https://pastebin.com/atjKuxY6">this</a> paste on <a href="https://pastebin.com">Paste Bin</a>, you can do so with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@systemoutput("curl -sS https://pastebin.com/raw/atjKuxY6")
</pre>
</div>
				</p>

				<h4 id="system-output-raw">Inputting system call output raw</h4>
				<p>
					Raw output from system calls may be inputted at any point when building webpages using <mono>\@systemraw(system-call)</mono>, where <mono>system-call</mono> is the system call or script you want to run.
				</p>

				<p>
					<b>Note:</b> you can use <mono>\'</mono> for <mono>'</mono> and <mono>\"</mono> for <mono>"</mono> in system-calls. 
				</p>

				<p>
					<b>Note:</b> Scripts and system calls are run from the project root directory so all paths in your scripts should start from there. Also do not change directory in your scripts as it will mess up the other threads that are also building pages. If you really must change directories in your scripts then you will have to set the number of build threads to 1 and change back to the project root directory before each script ends. Also you will not see the output of your scripts until after they have finished running, so user input is not recommended as you can not display a message.
				</p>

				<p>
					<b>Note:</b> <mono>\@systemraw</mono> calls do not scale very well to hundreds of thousands of calls, it is much better to combine as much as possible in to as few <mono>\@script</mono> calls as possible for extremely large projects (moving stuff to the pre/post build scripts is the best place, you can output stuff to file and process the files when building). For example if possible it's much faster to have a few pre-build scripts to download text from multiple urls using cURL, and/or make all the api calls, all the database queries, and work on JSON data needed and distribute the needed output in to different files to be inputted when needed. Note that page-specific build scripts have the benefit of multithreading, whereas site-wide build scripts wont have any multithreading unless you code it in there yourself.
				</p>

				<p>
					For example suppose you want to input the text from <a href="https://pastebin.com/atjKuxY6">this</a> paste on <a href="https://pastebin.com">Paste Bin</a>, you can do so with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@systemraw("curl -sS https://pastebin.com/raw/atjKuxY6")
</pre>
</div>
				</p>

				<h4 id="user-input">
					User input from command-line
				</h4>
				<p>
					To inject standard input from the user using the command-line in to the page being built you can use <mono>\@userin(message)</mono> where <mono>message</mono> is the message to be displayed on the command-line to the user.
				</p>

				<p>
					For example:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
\@userin("please enter your name:")
</pre>
</div>
				</p>

				<p>
					You can even input the message from file if you would like using <mono>\@userin*(\@input(message-file-path))</mono>, for example:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
\@userin*(\@input*("\@contentdir/input-message.txt"))
</pre>
</div>
				</p>

				<h4 id="user-file-input">
					User input from file
				</h4>
				<p>
					To inject input from the user from a file in to the page being built you can use <mono>\@userfilein(message)</mono> where <mono>message</mono> is the message/template to be displayed in the file opened up for the user to modify then save/close. 
				</p>

				<p>
					<b>Note:</b> you can choose which text editor is used with the <mono>unixTextEditor</mono> and <mono>winTextEditor</mono> settings in the <mono>.siteinfo/nsm.config</mono> configuration file in your website directory.
				</p>

				<p>
					For example:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
\@userfilein("please replace this text with your content")
</pre>
</div>
				</p>

				<p>
					You can even input the message from file if you would like using <mono>\@userfilein*(\@input(message-file-path))</mono>, for example:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
\@userfilein*(\@input*("\@contentdir/input-message.txt"))
</pre>
</div>
				</p>

				<p>
					<b>Note:</b> If you want to input the message/template from file without it being parsed by Nift's template language yet use <mono>\@inputraw(path-to-file)</mono> rather than <mono>\@input(path-to-file)</mono>.
				</p>

				<h4 id="css-files">
					Including css files
				</h4>
				<p>
					The best way to add CSS files is:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<link rel='stylesheet' type='text/css' href='\@pathtofile(path-to-css-file)'>
</pre>
</div>
					Note that by using <mono>\@pathtofile</mono> you will get a build error if the file does not exist (anymore). 
				</p>

				<p>
					Alternatively you can include a css file using <mono>\@cssinclude(path-to-css-file)</mono>, where <mono>path-to-css-file</mono> is the path from the main project directory to the css file (<u>not</u> the path from the page to the css file). When building a page, <mono>Nift</mono> will replace <mono>\@cssinclude(path-to-css-file)</mono> with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<link rel='stylesheet' type='text/css' href='path-from-page-to-css-file'>
</pre>
</div>
				</p>

				<h4 id="img-files">
					Including img files
				</h4>
				<p>
					The best way to add an image to your page is:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<img src="\@pathtofile(path-to-img-file)" width="120">
</pre>
</div>
					Note that by using <mono>\@pathtofile</mono> you will get a build error if the file does not exist (anymore). 
				</p>

				<p>
					Alternatively, you can include an image file using <mono>\@imginclude(path-to-img-file)</mono>, where <mono>path-to-img-file</mono> is the path from the main project directory to the img file (<u>not</u> the path from the page to the img file). When building a page, <mono>Nift</mono> will replace <mono>\@imginclude(path-to-img-file)</mono> with the following:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<img src="path-from-page-to-img-file">
</pre>
</div>
				</p>

				<h4 id="js-files">
					Including javascript files
				</h4>
				<p>
					The best way to add a javscript file is:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<script src="\@pathtofile(path-to-js-file)"></script>
</pre>
</div>
					Note that by using <mono>\@pathtofile</mono> you will get a build error if the file does not exist (anymore). 
				</p>

				<p>
					Alternatively, you can include a javascript file using <mono>\@jsinclude(path-to-js-file)</mono>, where <mono>path-to-js-file</mono> is the path from the main project directory to the js file (<u>not</u> the path from the page to the js file). When building a page, <mono>Nift</mono> will replace <mono>\@jsinclude(path-to-js-file)</mono> with: 

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<script src="path-from-page-to-js-file"></script>
</pre>
</div>
				</p>

				<h4 id="favicon-file">
					Including a favicon file
				</h4>
				<p>
					The best way to add a favicon file is:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<link rel='icon' type='image/png' href='\@pathtofile(path-to-favicon-file)'>
</pre>
</div>
					Note that by using <mono>\@pathtofile</mono> you will get a build error if the file does not exist (anymore). 
				</p>

				<p>
					Alternatively, you can include a favicon file using <mono>\@faviconinclude(path-to-favicon-file)</mono>, where <mono>path-to-favicon-file</mono> is the path from the main project directory to the favicon file (<u>not</u> the path from the page to the favicon file). When building a page, <mono>Nift</mono> will replace <mono>\@faviconinclude(path-to-favicon-file)</mono> with:

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint lang-js inline">
<link rel='icon' type='image/png' href='path-from-page-to-favicon-file'>
</pre>
</div>
				</p>

				<p>
					An example of using <mono>\@cssinclude(path-to-css-file)</mono>, <mono>\@jsinclude(path-to-js-file)</mono> and <mono>\@faviconinclude(path-to-favicon-file)</mono> is given below (I typically put these in a <mono>head.content</mono> file located in the <mono>template</mono> directory and included in the <mono>template/page.template</mono> file in between the <mono>\<head>\</head></mono> tags):

<div align="center" style="margin-top:-30px; margin-bottom:10px">
<pre class="prettyprint inline">
\@cssinclude("site/css/pagestyle.css")
\@jsinclude("site/js/motion.css")
\@faviconinclude("site/files/favicon.ico")
</pre>
</div>
				</p>
			</div>
		</section>
	</div>
</section>
